
  

   

    Предисловие
   

   «Чайльд-Роланд дошел до Темной Башни» — поэма Роберта Браунинга, написанная в 1855 году и впервые вышедшая в свет в том же году в сборнике под названием «Мужчины и женщины». Заголовок поэмы и, по совместительству, последние слова последней строфы, принадлежат перу Уильяма Шекспира. В пьесе «Король Лир» сын графа Глостера Эдгар придает доверия своей личине «бедного Тома из Бедлама» произнося бессмысленные речи, часть которых звучит так:
   

   Вот к башне наш Роланд идет,
   Опять тот молвил: «фу-фу-фу!
   Британской кровью как несет!».
   

   (Король Лир, Акт 3, Сцена 4. Пер. М.Кузмин)
   Шекспир черпал вдохновение в волшебной сказке Чайлд Роланд, хотя прямого отношения к пьесе сказка не имеет. Браунинг же утверждал, что поэма пришла к нему во сне уже полностью написанной. Браунинг описал путешествие Роланды в тридцати четырех шестистрочных строфах с рифмой A-B-B-A-A-B написанных пятистопным ямбом. Стихи проникнуты кошмаром ночных ужасов, но обстановка неожиданно реальна: никогда за свою творческую жизнь Браунинг не давал столь подробных описаний окружающего пейзажа. Несмотря на выразительность, данное произведение одно из самых непонятных в творчестве поэта, и это следствие того, что история главного героя показана только намеками, она второстепенна при создании образа душевного состояния героя.
   Предположительно, прообразом главного героя был паладин из «Песни о Роланде», поэме 11 века неизвестного французского автора. На эту мысль наталкивают имя героя — «Роланд», его духовой рог, названный в поэме «слагхорном» (псевдо средневековый инструмент, который упоминают Томас Чаттертон и Браунинг в своих произведениях), сугубо средневековая обстановка поэмы и титулу «чайлд» (средневековый термин, обозначающий отнюдь не ребенка, а рыцаря, не бывавшего в схватке, то есть «не проверенного»). Стихотворение начинается с размышлений Роланда о том, правдив ли человек рассказавший ему, как пройти к Темной Башне. Браунинг не пересказывает «Песнь о Роланде» дословно, отправной точкой для его повествования служит Шекспир. Угрюмый и циничный Роланд ищет путь к Башне попадая в разные неприятности в пути, хотя большинство преград надуманы и существуют лишь в его воображении. Поэма обрывается внезапно, когда он достигает своей цели, автор умалчивает о том, что он обнаружил там. Это тот самый случай, когда процесс (поиски Башни), важнее результата. Джудит Вейсман предположила, что цель автора была в том, чтобы показать как воинское понятие о чести и славе «разрушает внутренний мир потенциального героя заставляя нас увидеть мир, злобно искаженный в сознании Роланда». Вильям Лайон Фелпс предлагает три различные интерпретации поэмы: в первых двух — Башня это символ рыцарского поиска. Успех приходит только через поражение и осознания тщетности исполнения мечты. В третьей интерпретации Башня это просто синоним проклятия.
   © Русская Википедия
   

   В этом сборнике мы представляем Вашему вниманию три самых известных перевода поэмы.
  

  

   

    Чайльд-Роланд дошел до Темной Башни
   

   I
   И мнилось мне — он в каждом слове лгал.
   Уродец престарелый с хитрым взором,
   Желавший, чтобы путь сей лжи избрал
   Покорно я… яд желчи изливал,
   Указывал — и видел: я внимал,
   И видел, как меня схоронит вскоре.
   

   II
   Зачем он, с палкой этой, здесь вдали
   Покинут? Только чтоб сбивать с дороги
   Тех странников, что до него дошли!
   Как череп ухмылялся… вспомнят ли
   Меня — среди оставшихся в пыли
   Им посланных на гибель — слишком многих?
   

   III
   Он говорил — я должен повернуть
   На ту дорогу, что, как всем известно,
   Откроет к Темной Башне трудный путь…
   Я понял поневоле: это — суть.
   О гордости забыть и цепь замкнуть…
   Конец — и прах, и нет надеждам места.
   

   IV
   Я странствовал по тропам всей земли,
   И в призрак обратился отсвет цели,
   Искал — и годы под ноги легли…
   Успеха нет, преграды столь же злы,
   И осознанье горче, чем полынь,
   И майским сном желанья отлетели.
   

   V
   Я — как больной, что смерти обречен,
   Что жив, увы, последние мгновенья.
   Уже с друзьями распрощался он,
   Уже его не слышен жалкий стон…
   (Свободой умиранья усыплен,
   Одет далекой скорбью, словно тенью…)
   

   VI
   'А есть ли место средь иных могил?
   'А кладбище, по счастью, недалеко?
   Обрядов грустных час уж избран был -
   А он еще живет, он слух открыл,
   Пытается ответить — нету сил!
   И нет стыда у смертного порога.
   

   VII
   Я — странник. Я страдал. Я видел зло,
   Пророчества, оставшиеся ложью.
   О, мой Отряд! Вас столько полегло!
   Смерть — с каждым шагом, гибель — за углом,
   Умолкли клятвы, как весенний гром…
   Дорога к Темной Башне — бездорожье.
   

   VIII
   Тих, как само отчаянье, свернул
   На путь, что указал уродец старый.
   День ужасом кромешным промелькнул,
   Тоской закат сквозь сумерки взглянул,
   И луч кровавый отблеском сверкнул -
   К равнине, полной лживого угара.
   

   IX
   Но — к цели! Оказался вскоре я
   На пустоши, бурьяна полной злого.
   Смотрю назад — дорога и поля.
   Здесь — мертвая бесплодная земля
   До горизонта утомляет взгляд.
   Идти вперед — нет для меня иного!
   

   X
   И я иду. Увы, мне никогда
   Пейзаж столь безотрадный не встречался…
   Цветов иль просто трав — нет и следа,
   Лишь сорняков и терний череда,
   Что землю захватила без стыда…
   Здесь свежий лист бы чудом показался!
   

   XI
   Уродство, безнадежность, нищета -
   Печален сей удел земли несчастной.
   Речет Природа: 'Глянь, избывши страх,
   Иль отвернись… вокруг — лишь пустота.
   Покуда Суд Последний не настал,
   Не проявлю ни малого участья!
   

   XII
   Кто опалил огнем чертополох,
   Ко мне ростки последние тянувший?
   Кто листья полевицы злобно сжег,
   На медленную смерть ее обрек?
   Казалось, тот злодей — сам мрачный рок,
   Что, забавляясь, губит все, что суще!
   

   XIII
   Уныло стебли тянутся сквозь грязь,
   Как волосы сраженного чумою.
   Земля — кроваво-слизистая мразь.
   Здесь конь слепой стоит не шевелясь…
   Откуда? Словно дьявол, веселясь,
   Из адских бездн привел его с собою!
   

   XIV
   Он жив? О нет! Он мертв уж сотни лет.
   Пусты глазницы, ветер спутал гриву,
   И плоть гниет, и обнажен скелет.
   Уродств таких, я мнил когда-то, нет!
   Он, верно, стал причиной многих бед,
   Чтоб отомстили местью — столь глумливой!
   

   XV
   Закрыв глаза, в себя я загляну…
   Так перед боем кубок выпивают!
   Я к светлым дням прошедшего взываю,
   Чтоб будущее не влекло ко дну.
   Подумай и сразись… я вспоминаю,
   Я хмель былого радостно сглотну!
   

   XVI
   Зачем явился Катберта мне лик,
   С улыбкою, что радостно светила?
   Почти что въяве он во мгле возник,
   И засмеялся звонко, как привык,
   И обнял крепко на единый миг…
   Но ночь печали друга поглотила!
   

   XVII
   Вот Джайлс — и я отважней не встречал.
   Не знал сомнений, страха и упрека,
   Был беспощадней острого меча…
   Но предал он — и руки палача
   В позоре оборвали жизнь до срока.
   И весь Отряд с презреньем промолчал!
   

   XVIII
   Нет — я вернусь на свой ужасный путь.
   Ушедшего тоска еще печальней!
   Ни шороха, ни звука… не взглянуть.
   Хоть мыши бы летучей здесь мелькнуть…
   Отчаянье мою сдавило грудь -
   Но… видно что-то на дороге дальней.
   

   XIX
   Из ниоткуда — узкая река.
   Тиха и незаметна, как гадюка,
   Почти бездвижна!.. В тине берега.
   Здесь демоны — мне истина порукой -
   От крови отмывают, верно, руки,
   И гладь воды взрезают их рога.
   

   XX
   Змея мала — но сколько яду в ней!
   Ольхи стволы у берегов склоненны,
   Отравою смертельной напоенны,
   Самоубийц отчаянных мрачней!
   Река убила соки их корней
   Погибелью, в глубинах потаенной.
   

   XXI
   Я вброд пошел — о Боже, я вот-вот
   Ступлю ногой на чей-то череп стылый!
   Копье — опора. Омуты — могилы,
   В них плоть, живая некогда, гниет.
   Крик крысы водяной — и нету силы,
   Ведь он, как детский плач, меня гнетет!
   

   XXII
   Брод завершен. Брег новый предо мной.
   Там будет лучше? Жалкая надежда!
   Бойцы, увы, сомкнули в смерти вежды,
   И поле брани смертной пеленой
   Окутано… Стоял здесь вопль кромешный.
   Кто выжил? Жабы в нежити ночной…
   

   XXIII
   Да, — верно, поле битвы было тут.
   Но что свело бойцов на пир кровавый?
   Нет ни следа их подвигов и славы,
   Помину нет… Безумцев не поймут!
   Как крестоносцев ратные забавы,
   Иль как рабов галерных тяжкий труд.
   

   XXIV
   Форлонга не пройти — здесь сталь и смрад.
   Кто обратил все эти механизмы,
   Зубцы, колеса эти — против жизни?
   Чей взор безумный через эти призмы
   На мертвые тела глядеть был рад?
   Чей зуб стальной вгрызался в смертный ад?
   

   XXV
   И снова — в путь… Песок, туман и мрак.
   Стволы мертвы. Лес, верно, благородный
   Здесь шелестел… и стал землей холодной.
   Безумство, исступленье! Верно, так
   Из хлама создает себе дурак
   Кумир — и с криком носится бесплодно.
   

   XXVI
   Нет яркого пятна! Унылый свет,
   И мох, что мерзко клочьями свисает, -
   Да плесень заржавелая мерцает.
   А вот и дуб, гнилушками одет -
   За жизнь боролся, плоть коры взрезая,
   И, издыхая, проклял белый свет!
   

   XXVII
   И нет пути по-прежнему конца!
   Прошел недалеко, но тьма ночная
   Меня остановиться понуждает.
   И ворон, верный спутник мертвеца,
   Скользя, кружит у моего лица,
   И рваный плащ, играя, задевает.
   

   XXVIII
   Я бросил взгляд вперед и осознал:
   Равнина обернулась кряжем горным.
   Не достигаю зрением проворным
   Я ничего — кроме суровых скал
   И пропастей, ведущих к безднам черным.
   'Как здесь пройти? — я с ужасом гадал.
   

   XXIX
   Не сразу осознал я — как меня
   Жестоко провели! Когда? Не знаю!
   Во сне? В кошмаре? Тихо отдыхаю.
   Закончен путь? Иль часть пути? Но я
   Почти что сдался — и ловушка злая
   Открылась уж, забвением маня…
   

   XXX
   И вдруг — ожгло. И вдруг я понял — да!
   Вот место это! За двумя холмами,
   Что, как быки, сплетенные рогами,
   Сошлись в бою!., а дальше — скал чреда, Гора…
   Глупец, ты столько шел сюда!
   Ты звал, толкал, пинал себя годами!
   

   XXXI
   Что ж в сердце гор? Да — Башня, Боже мой!
   Покрытый мхами камень, окна слепы
   И — держит мир собою?! Как нелепо!
   Несет всю силу мощи временной?
   Над ней летят века во мгле ночной,
   Пронзает дрожь меня, как ветра вой!
   

   XXXII
   Как, не видать?! Ее укрыла ночь?
   Не верю! День уж занялся и сгинул,
   Закат лучи последние низринул
   На горы и холмы, и сумрак хлынул
   Мне в очи, что узрели беспорочь:
   'Конец творенья — миру не помочь!
   

   XXXIII
   Как, не слыхать?! Но воздух полнит звук,
   Он нарастает, как набат над битвой,
   Он полнит звоном, громом все вокруг,
   И имена товарищей забытых,
   Что шли со мной, мне называет вдруг.
   О, храбрецы! Потеряны, убиты!
   

   XXXIV
   Миг — и они восстали из могил,
   Пришли ко мне печальными холмами,
   И каждый — мой оплот, огонь и знамя!
   Я, их узнав, колени преклонил,
   Поднял свой верный рог — и протрубил
   Во имя их, погибших, падших, павших:
   'Вот Чайльд-Роланд дошел до Темной Башни!
   

   Перевод — Нана Эристави
  

  

   

    Чайлд Роланд к Тёмной Башне пришёл
   

   I
   Калека древний и седой — он лгал,
   И взгляд его наполнен злобой был,
   Когда он, объясняя путь, следил,
   Как я покорно лжи его внимал -
   Беззубый рот, кривившись, выдавал,
   Что в мыслях он меня похоронил.
   

   II
   Зачем его оставить здесь могли,
   Как если не сбивать с дороги тех,
   Дошедших до него? Быть может, смех
   Он сдерживал — и трещины земли
   Им были эпитафией в пыли,
   Когда он посылал на смерть их всех.
   

   III
   Его слова — мне дальше не пройти,
   Мне надо повернуть на этот тракт,
   Что уведет от Темной Башни в мрак…
   Я понял: предо мной — конец пути,
   И рядом цель, что я мечтал найти…
   Но смысл за годы обратился в прах,
   

   IV
   Как будто мое странствие во мгле,
   Мой поиск, длившийся так много лет,
   Сознанья тихо загасили свет -
   Так тает след дыханья на стекле.
   Лишь сердце бьется яростно во мне -
   И резонанс в ушах звенит в ответ -
   

   V
   Моей души потухшей слабый стон…
   Я — словно умирающий больной,
   Почти что труп, но все еще живой,
   Когда уже ушли друзья, и он
   Один, и ум туманом окружен -
   И слушает беседу за стеной.
   

   VI
   «А есть ли рядом кладбище?» «А где
   Мы проведем обряд?» «А сможем мы -
   Как хорошо, что снег сошел с зимы! -
   Все приготовить, например, к среде?» -
   Так говорят о всякой ерунде -
   И в ярости он рвется к ним из тьмы.
   

   VII
   Я долго странствовал. Я видел кровь,
   Пророчества, мечты, что не сбылись.
   Друзья мои в Отряде, что клялись
   Дойти до Башни — вновь, и вновь, и вновь
   Я видел их тела, и вся любовь
   Друг к другу не могла спасти… И ввысь
   

   VIII
   Глаза бездумно смотрят. Это мой Удел?
   И я свернул, не слыша слов,
   От в воздухе звенящих голосов,
   От зла калеки на дороге той -
   В кошмар, его указанный рукой -
   К закату из моих ужасных снов.
   

   IX
   Я обернулся шага через два -
   В последний раз увидеть путь назад -
   Но ни дороги, ни калеки — в ряд
   Стоит за мной засохшая трава,
   Что шелестит в безветрие едва,
   И не на чем остановить свой взгляд.
   

   X
   Итак, опять вперед! Я никогда
   Природы безнадежней не встречал -
   Всю пустошь молочай заполонял,
   Корявый, грязный куколь без стыда,
   Крадучись, тихо пробрался сюда
   И почву плодородную украл.
   

   XI
   Нужда, гримасы, ужаса печать -
   Удел этой страны. «Ну что ж, смотри -
   Или закрой глаза!» — слова земли,
   Что под ноги ложится умирать.
   Здесь некому и нечего терять -
   Лишь Страшный Суд проказу исцелит.
   

   XII
   Обугленный чертополох ко мне
   Тянул свои останки; рядом с ним,
   Без листьев, с стеблем жалобным одним,
   Дрожала полевица. По весне,
   Пожарища мрачней, в предсмертном сне
   Встречала пустошь солнца едкий дым.
   

   XIII
   Как вылезшие волосы редки,
   Травинки тонкие пронзают грязь -
   Запекшуюся кровь; не шевелясь,
   Стоит слепая лошадь. Чьи клыки
   На шкуре след прожгли? Кто васильки
   Гниющие вплел в гриву, веселясь?
   

   XIV
   Живая ли? Она давно мертва,
   Застыла плоть, и прахом стал скелет.
   Она не может жить — и все же нет!
   Вросла в копыта сорная трава,
   Глаза истлели — но она жива!
   На ней проклятье — миллиарды лет.
   

   XV
   И взор тогда я к сердцу обратил.
   Как перед битвой ищущий вина,
   Сознанье я освобождал от сна -
   Былых времен глоток придаст мне сил,
   Один глоток, вот все, что я просил -
   Чтоб разошлась видений пелена.
   

   XVI
   О, нет! Из топких памяти глубин
   Мне тихо Катберт улыбнулся вдруг.
   Мой самый верный, мой надежный друг!
   Твой смех всегда со мной. Но ряд картин
   Позорных лик затмил… Я вновь один -
   И снова замирает сердца стук.
   

   XVII
   И Джайлс пришел ко мне. Он, как свеча,
   Горел прозрачным пламенем. Он честь
   Всего превыше ставил. Но не счесть
   Предателей — и руки палача
   Нашли пергамент, а друзья, крича,
   Свершили сами горестную месть.
   

   XVIII
   Уж лучше настоящее мое,
   Ад, испускающий зеленый гной,
   Чем то, что стынет в мраке за спиной…
   Ни звука. Может, извернет свое
   Нутро старуха-ночь — и все зверье,
   Визжа и воя, бросится за мной?
   

   XIX
   Внезапно незаметная река
   Подкралась, заарканила мой путь.
   Движенья нет. Коричневая муть
   И пена покрывают берега.
   Наверно, дьявол моет здесь рога,
   На миг остановившись отдохнуть.
   

   XX
   Малютка ядовитая! Ольхи
   Стволы скривились, серы и мертвы.
   Самоубийцы-ивы, без листвы,
   Отчаялись замаливать грехи,
   Их корни безнадежны и сухи -
   Распороты здесь мирозданья швы.
   

   XXI
   О, все святые, как боялся я,
   Переходя речушку смерти вброд,
   На мертвеца наткнуться в пепле вод,
   Иль, опираясь на древко копья,
   С ним в омут провалиться! Да, моя
   Душа дрожала, исторгая пот!
   

   XXII
   Я рад был переправу завершить -
   В надежде, что увижу лучший край.
   Увы! На этом месте чей-то рай
   Пал под косой войны. Остались жить
   Лишь жабы в ядовитых лужах, сныть
   И в клетках — тени злых кошачьих стай.
   

   XXIII
   Да, то была арена битвы битв.
   Но что свело их здесь на страшный бой?
   И нет следов — ни мертвый, ни живой
   Не вышел из него. Ни плач молитв,
   Ни шелест времени незримых бритв
   Не нарушали здешний злой покой.
   

   XXIV
   И кто все механизмы обратил,
   Что в пыль затоптаны, на боль и ад?
   Кто направлял их, чей безумный взгляд
   Тела и души резать дал им сил?
   Кто их почистил, смазал, наточил -
   И бросил испускать кровавый смрад?
   

   XXV
   Я медленно, но верно шел вперед.
   Болота, камни, голая земля
   Безмолвная. Забытые, стоят
   Иссохшие деревья. Мой приход
   Не потревожит их. Лишь небосвод
   Мне бросит вслед свой равнодушный взгляд.
   

   XXVI
   Здесь — краски скрыты пятнами, и мох,
   Заплесневелый, ржавый, вековой,
   Разбитый, издыхающий, гнилой
   Клочками расстилается у ног.
   Там — дуб боролся за прощальный вздох,
   Но смерти проиграл неравный бой.
   

   XXVII
   И нет конца пути! Тускнеет свет,
   Ложится в грязный сумрак тишина.
   В сознании восстала ото сна
   Тень прошлого. Найду ль я в ней ответ?
   Она, быть может, лучший даст совет -
   И сдастся мне проклятая страна.
   

   XXVIII
   И, посмотрев вокруг, я осознал,
   Что как-то вырос. Горный жуткий кряж
   Схватил меня в кольцо. Опять мираж?
   Закат померк на склонах серых скал,
   Исчезла пустошь. Это ль я искал?
   В тупик завел калека, темный страж.
   

   XXIX
   Не до конца я понял, что меня
   Бесчестно провели. Кошмарный путь
   Закончился. Ты можешь отдохнуть,
   Шептали мне с небес осколки дня.
   И я, себя и Господа кляня,
   Не знал, о чем просить, куда свернуть.
   

   XXX
   Но вдруг, как луч над морем, как маяк,
   Сверкнула память. Я сошел с ума!
   Я знаю, где я! Эти два холма,
   Высокая гора… Дурак! Дурак!
   Ведь прямо пред тобой — последний знак!
   Слепец! Твои глаза застила тьма!
   

   XXXI
   А в центре — Башня… Темный силуэт,
   Слепые окна, грязный камень, прах… -
   И мир весь держит на своих плечах,
   В ней все, что было, будет — сонмы лет,
   День завтрашний, погасший ночью свет.
   И тут я понял, что такое страх.
   

   XXXII
   Не видел? Темнота вокруг? Нет, день
   Вчерашний снова здесь! Пылает твердь,
   Холмы взирают сверху — круговерть
   Багряных туч не дарит больше сень -
   С их лиц суровых уползает тень.
   Они мою хотят запомнить смерть.
   

   XXXIII
   Не слышал? Но заполнил воздух звук!
   Зовет в ушах, как колокольный звон.
   И тысячи забытых мной имен
   Бросаются ко мне. Движенья рук
   И глаз, и шепот: «Мы с тобою, друг!»
   Нахлынули огнем со всех сторон.
   

   XXXIV
   Они пришли сюда, на склон холмов,
   Меня направить на последний шаг.
   Я вижу их. Они — моя душа.
   Ждет верный рог. Я к вызову готов.
   И здесь, на перекрестье всех миров,
   Я протрубил…
   

   Перевод — Ксения Егорова
  

  

   

    Роланд до Замка черного дошел
   

   I
   Сначала я подумал, что он лжет,
   Седой калека, хитрый щуря глаз,
   Глядел он — на меня насторожась,
   Как ложь приму я. Был не в силах рот
   Скривившийся усмешки скрыть, что вот
   Еще обману жертва поддалась.
   

   II
   Не для того ль стоит он здесь с клюкой,
   Чтоб совращать заблудших? Чтоб ловить
   Доверчивых, решившихся спросить
   Дорогу? Смех раздался б гробовой,
   И он в пыли дорожной вслед за мной,
   Мне стал бы эпитафию чертить.
   

   III
   Когда б свернул я, выполнив совет,
   На путь зловещий, где, всего верней,
   Скрывался Черный замок. Но в своей
   Покорности свернул туда я. Свет
   Надежды меркнет, гордости уж нет.
   Любой конец, но только поскорей.
   

   IV
   Так много лет я в поисках бродил,
   Так много стран пришлось мне обойти,
   Надежда так померкла, что почти
   Я сердца своего не осудил,
   Когда в нем счастья трепет ощутил,
   Что неуспех — конец всему пути.
   

   V
   Так часто мертвым кажется больной,
   Но жив еще. Прощанием глухим
   Возникнув, смолкнет плач друзей над ним.
   И слышит он — живые меж собой
   Твердят: «скончался» — «свежестью ночной
   Поди вздохни» — «удар непоправим».
   

   VI
   Затем, найдется ль место, говорят,
   Среди могил семейных, как пышней
   Похоронить, в какой из ближних дней.
   Обсудят банты, шарфы, весь обряд.
   А тот все слышит, и ему назад
   Вернуться страшно в круг таких друзей.
   

   VII
   И я — блуждать так долго мне пришлось,
   Так часто мне сулили неуспех,
   Так значился всегда я в списке тех,
   Кто рыцарский обет свой произнес
   Увидеть Черный замок, что вопрос, -
   Не лучше ль уж погибнуть без помех.
   

   VIII
   Спокойно, безнадежно, где старик
   Мне указал с дороги вглубь свернуть,
   Там и свернул я. День светлел чуть-чуть.
   И мрачно стало к ночи. Но на миг
   Багровым оком дымку луч проник -
   На то, как схватит степь меня, взглянуть.
   

   IX
   И точно, сделав несколько шагов,
   Я обернулся, чтобы след найти
   Пройденного, надежного пути.
   Но сзади было пусто. До краев
   Один степной, сереющий покров.
   Вперед, мне больше некуда идти.
   

   X
   И я пошел. Бесплодный, гнусный край,
   Печальнее я места не встречал. Цветы? -
   Еще б я кедров здесь искал!
   Но без помех бурьян и молочай
   Обильный приносили урожай.
   Здесь колос редкой бы находкой стал.
   

   XI
   Но нет, нужда с бесплодием кругом
   Слились в одно. «Смотри на этот вид,
   Иль нет, — Природа, мнилось, говорит, -
   Я здесь бессильна. Разве что огнем
   Здесь судный день очистит каждый ком
   И узников моих освободит».
   

   XII
   Чертополоха рослые кусты
   Обиты — это зависть низких трав.
   Лопух шершавый порван и дыряв
   До полной безнадежности найти
   Побег зеленый. Видно, здесь скоты
   Прошли, по-скотски жизни оборвав.
   

   XIII
   Трава — как волос скудный и сухой
   На коже прокаженных. Из земли
   Торчат кровавой поросли стебли.
   И конь недвижный, тощий и слепой,
   С конюшни чертом выгнанный долой,
   Стоит, в оцепенении, вдали.
   

   XIV
   Живой? — сойти за мертвого он мог.
   На бурой гриве — ржавчины налет.
   Ослепший… шею вытянув вперед,
   Он был смешон, ужасен и убог…
   О, как мою он ненависть разжег,
   И кару, знать, за дело он несет.
   

   XV
   Тогда я в память заглянул свою.
   Как ждет вина пред битвою солдат,
   Так жаждал я на счастие, назад,
   Хоть раз взглянуть, чтоб выдержать в бою.
   Завет бойца — «обдумай и воюй».
   Один лишь взгляд — и все пойдет на лад.
   

   XVI
   Но не моею памятью помочь.
   Вот Кудберт милый… золото кудрей…
   Лица румянец, вот руки моей
   Коснулся словно, держит он, точь-в-точь
   Как прежде… Ах, одна позора ночь,
   И гаснет пламя, холод вновь сильней.
   

   XVII
   Вот Джайльс встает в сознании моем.
   Вот, в рыцари впервые посвящен,
   Клянется он, что честь ему закон.
   Но фу! Какой пергамент палачом
   На грудь ему приколот? Что кругом
   Кричат друзья? — Изменник, проклят он!
   

   XVIII
   Нет, лучше настоящая пора,
   Чем эта быль. И я иду опять.
   Все пусто. Тишь. Что вздумает послать
   Навстречу ночь — сову ль, нетопыря?
   Но что-то вдруг во мраке пустыря
   Возникнуло, чтоб мысль мою прервать.
   

   XIX
   Подкравшись незаметно, словно змей,
   Внезапно мне прорезал путь поток,
   Он не был мрачно-медленным, он мог,
   Бурля и пенясь, омывать скорей
   Копыта раскаленные чертей,
   Так в нем клубился пены каждый клок.
   

   XX
   Он мелок, но зловреден. Вдоль воды
   Склонялись ольхи. В злой водоворот
   Стремились ивы, головой вперед, -
   Самоубийц отчаянных ряды.
   О, то поток довел их до беды!
   И равнодушно мимо он течет.
   

   XXI
   Я вброд пошел. О, как велик был страх,
   Что вдруг ступлю на трупа я оскал,
   Копьем ища свой путь, я ощущал,
   Как вязнет, словно в чьих-то волосах,
   Чуть крысу я копьем задел — в ушах,
   Казалось, крик ребенка прозвучал.
   

   XXII
   Теперь уж путь не будет так суров.
   Но нет, надежда снова неверна.
   Кто здесь топтался? Кем велась война?
   Чьей битвой стоптан почвенный покров?
   Жаб в луже с ядом? Диких ли котов,
   Чья клетка докрасна раскалена?
   

   XXIII
   Так в адский круг был замкнут их порыв.
   Среди равнины гладкой, что бойцов
   Сюда влекло? Отсюда нет следов…
   Сюда их нет… безумие внушив,
   То сделал яд. Так турок рад, стравив
   Евреев и христьян, своих рабов.
   

   XXIV
   Что дальше там? Не колесо ль торчит?
   Нет, то скорей трепало, чьи клыки
   Тела людские рвали на клочки,
   Как шелковую пряжу. То на вид
   Орудье пытки. Брошено ль лежит?
   Иль ждут точила ржавые клинки?
   

   XXV
   А вот участок гиблый. Прежний лес
   Сменился здесь болотом. Болотняк
   Стал пустырем. Безумец, верно, так
   Вещь смастерив, — испортив, интерес
   Теряет к ней и прочь уходит. Здесь
   С песком смешались щебень, грязь и шлак.
   

   XXVI
   То прыщиком, то ярким пупырем
   Пестрит земля. Бесплодный каждый склон,
   Как будто гноем, мохом изъязвлен…
   И дуб стоит. Разбит параличом,
   Разинутою щелью, словно ртом,
   Взывая к смерти, умирает он.
   

   XXVII
   А цель все так же скрыта, как была.
   Все пусто. Вечереет. И никак
   Путь не намечен дальше. Но сквозь мрак
   Возникла птица — вестник духа зла -
   Драконовыми перьями крыла
   Меня коснулась, — вот он, жданный знак.
   

   XXVIII
   Тут поднятому взгляду моему
   Открылось, что равнины прежней гладь
   Замкнули горы, если так назвать
   Громад и глыб бесформенную тьму.
   И как я им попался — не пойму,
   Но не легко уйти мне будет вспять.
   

   XXIX
   И понимать я начал — в этот круг
   Лишь колдовством сумел я забрести,
   Как в страшном сне. Нет далее пути.
   И я сдаюсь. Но в это время звук
   Раздался вслед за мною, словно люк
   Захлопнулся. Я, значит, взаперти.
   

   XXX
   И сразу вдруг узнал я все кругом:
   Как два быка, направо пара скал
   Сплелась рогами в битве. Слева встал
   Утес облезлый. О, каким глупцом
   Я выглядел в безумии своем,
   Когда своей же цели не узнал.
   

   XXXI
   Не Черного ли замка то массив,
   Слеп, как безумца сердце, там лежит,
   Округлый, низкий? В целом свете вид
   Такой один. Так бури дух, игрив,
   Тогда лишь моряку покажет риф,
   Когда корабль надломленный трещит.
   

   XXXII
   Как не увидеть было? Ведь назад
   Нарочно день огнем сверкнул в прорыв:
   Охотники-утесы, положив
   В ладони подбородки, вкруг лежат
   И как за дичью загнанной следят:
   «Пора кончать, кинжал в нее вонзив».
   

   XXXIII
   Как не услышать? Звон врывался в слух,
   И все гремело множеством имен.
   Как тот был смел, как этот был силен,
   Удачлив тот, но все, за другом друг,
   Увы, увы, погибли. Вот вокруг
   На миг поднялся гул былых времен
   

   XXXIV
   И встали все, чтоб жребий видеть мой,
   Замкнувши рамой пламенною дол.
   Я всех в огне на скалах перечел,
   Я всех узнал, но твердою рукой
   Я поднял рог и вызов бросил свой:
   «Роланд до Замка черного дошел».
   

   Перевод — Валентина Давиденкова
  

 


          See more books in http://www.e-reading.club


Шифр Вернама (англ. Verrnam Cipher) — система симметричного шифрования, изобретённая в 1917 году сотрудником AT&T Гилбертом Вернамом[1].

Шифр является разновидностью криптосистемы одноразовых блокнотов. В нём используется булева функция «Исключающее ИЛИ». Шифр Вернама является примером системы с абсолютной криптографической стойкостью[2]. При этом он считается одной из простейших криптосистем[3].

Шифр назван в честь телеграфиста AT&T Гильберта Вернама, который в 1917 году изобрёл, а в 1919 запатентовал систему автоматического шифрования телеграфных сообщений.

Вернам не использовал понятие «Исключающее ИЛИ» в патенте, но реализовал именно эту операцию в релейной логике. Каждый символ в сообщении преобразовывался побитовым XOR (исключающее ИЛИ) с ключом бумажной ленты[4].

Вернам создал устройство, производящее указанные операции автоматически, без участия шифровальщика. Тем самым было положено начало так называемому «линейному шифрованию», когда процессы шифрования и передачи сообщения происходят одновременно. До той поры шифрование было предварительным, поэтому линейное шифрование существенно повышало оперативность связи .

Не будучи шифровальщиком, тем не менее, Вернам верно заметил важное свойство своего шифра — каждая лента должна использоваться только один раз и после этого уничтожаться. Это трудноприменимо на практике — поэтому аппарат был переделан на несколько закольцованных лент с взаимно простыми периодами[5].

Криптосистема была предложена для шифрования телеграфных сообщений, которые представляли собой бинарные тексты, в которых открытый текст представляется в коде Бодо (в виде пятизначных «импульсных комбинаций»). В этом коде, например, буква «А» имела вид (1 1 0 0 0). На бумажной ленте цифре «1» соответствовало отверстие, а цифре «0» — его отсутствие. Секретный ключ должен был представлять собой хаотичный набор букв того же самого алфавита[5].

Для получения шифротекста открытый текст объединяется операцией «исключающее ИЛИ» с секретным ключом. Так, например, при применении ключа (1 1 1 0 1) на букву «А» (1 1 0 0 0) получаем зашифрованное сообщение (0 0 1 0 1): {\displaystyle (11000)\oplus (11101)=(00101)} {\displaystyle (11000)\oplus (11101)=(00101)} Зная, что для принимаемого сообщения имеем ключ (1 1 1 0 1), легко получить исходное сообщение той же операцией: {\displaystyle (00101)\oplus (11101)=(11000)} {\displaystyle (00101)\oplus (11101)=(11000)} Для абсолютной криптографической стойкости ключ должен обладать тремя критически важными свойствами[2]:

Иметь случайное равномерное распределение: {\displaystyle P_{k}(k)=1/2^{N}} P_{k}(k)=1/2^{N}, где k — ключ, а N — количество бинарных символов в ключе;
Совпадать по размеру с заданным открытым текстом;
Применяться только один раз.
Также хорошо известен так называемый шифр Вернама по модулю m, в котором знаки открытого текста, шифрованного текста и ключа принимают значения из кольца вычетов Zm. Шифр является обобщением оригинального шифра Вернама, где m = 2[2].

Например, кодирование шифром Вернама по модулю m = 26 (A=0,B=1,…, Z=25):

Ключ:           EVTIQWXQVVOPMCXREPYZ 
Открытый текст: ALLSWELLTHATENDSWELL (All's well that ends well)
Шифротекст:     EGEAMAIBOCOIQPAJATJK

Без знания ключа такое сообщение не поддаётся анализу. Даже если бы можно было перепробовать все ключи, в качестве результата мы получили бы все возможные сообщения данной длины плюс колоссальное количество бессмысленных дешифровок, выглядящих как беспорядочное нагромождение букв. Но и среди осмысленных дешифровок не было бы никакой возможности выбрать искомую. Когда случайная последовательность (ключ) сочетается с неслучайной (открытым текстом), результат этого (шифротекст) оказывается совершенно случайным и, следовательно, лишённым тех статистических особенностей, которые могли бы быть использованы для анализа шифра.[6].

Криптографическая стойкость

В 1945 году Клод Шеннон написал работу «Математическая теория криптографии» (рассекреченную только после Второй мировой войны в 1949 г. как «Теория связи в секретных системах»), в которой доказал абсолютную стойкость шифра Вернама. То есть перехват шифротекста не даёт никакой информации о сообщении. С точки зрения криптографии, невозможно придумать систему безопаснее шифра Вернама[2]. Требования к реализации подобной схемы достаточно нетривиальны, поскольку необходимо обеспечить наложение уникальной гаммы, равной длине сообщения, с последующим её гарантированным уничтожением. В связи с этим коммерческое применение шифра Вернама не так распространено в отличие от схем с открытым ключом и он используется, в основном, для передачи сообщений особой важности государственными структурами[5].

Приведём доказательство абсолютной криптографической стойкости. Пусть сообщение представлено двоичной последовательностью длины {\displaystyle N:m=m_{1},m_{2},\ldots ,m_{n}} N:m=m_{1},m_{2},\ldots ,m_{n}. Распределение вероятности сообщений {\displaystyle P_{m}(m)} P_{m}(m) может быть любым. Ключ так же представлен двоичной последовательностью {\displaystyle k=k_{1},k_{2},\ldots ,k_{n}} k=k_{1},k_{2},\ldots ,k_{n} той же длины но с равномерным распределением {\displaystyle P_{k}(k)=1/2^{N}} P_{k}(k)=1/2^{N} для всех ключей.

В соответствии со схемой шифрования, произведём шифротекст, покомпонентно суммируя по модулю 2 последовательности открытого текста и ключа:

{\displaystyle C=M\oplus K=(m_{1}\oplus k_{1},m_{2}\oplus k_{2},\ldots ,m_{N}\oplus k_{N})} C=M\oplus K=(m_{1}\oplus k_{1},m_{2}\oplus k_{2},\ldots ,m_{N}\oplus k_{N})
Легальный пользователь знает ключ и осуществляет расшифрование:

{\displaystyle M=C\oplus K=(c_{1}\oplus k_{1},c_{2}\oplus k_{2},\ldots ,c_{N}\oplus k_{N})} M=C\oplus K=(c_{1}\oplus k_{1},c_{2}\oplus k_{2},\ldots ,c_{N}\oplus k_{N})
Найдём вероятностное распределение N-блоков шифротекстов, используя формулу:

{\displaystyle P(c=a)=P(m\oplus k=a)=\sum _{m}{P(m)}P(m\oplus k=a|m)=\sum _{m}{P(m)P(m)1/2^{N}}=1/2^{N}} P(c=a)=P(m\oplus k=a)=\sum _{m}{P(m)}P(m\oplus k=a|m)=\sum _{m}{P(m)P(m)1/2^{N}}=1/2^{N}
Результат подтверждает известный факт о том, что сумма двух случайных величин, одна из которых имеет равномерное распределение, является случайной величиной с равномерным распределением. Таким образом, в нашем случае распределение шифротекстов равномерное.

Запишем совместное распределение открытых текстов и шифротекстов:

{\displaystyle P(m=a,c=b)=P(m=a)P(c=b|m=a)} P(m=a,c=b)=P(m=a)P(c=b|m=a)
Найдём условное распределение

{\displaystyle P(c=b|m=a)=P(m\oplus k=b|m=a)=P(k=b\oplus a|m=a)=P(k=b\oplus a)=1/2^{N},} P(c=b|m=a)=P(m\oplus k=b|m=a)=P(k=b\oplus a|m=a)=P(k=b\oplus a)=1/2^{N},
так как ключ и открытый текст являются независимыми случайными величинами. Итого:

{\displaystyle P(c=b|m=a)=1/2^{N}} P(c=b|m=a)=1/2^{N}
Подстановка правой части этой формулы в формулу для совместного распределения даёт

{\displaystyle P(m=a,c=b)=P(m=a)1/2^{N}} P(m=a,c=b)=P(m=a)1/2^{N}
Что доказывает независимость шифротекстов и открытых текстов в этой системе. Это и означает абсолютную криптографическую стойкость[7].

Область применения
В настоящее время шифрование Вернама используется достаточно редко. В большой степени из-за существенного размера ключа, длина которого должна совпадать с длиной сообщения. То есть, использование таких шифров требует огромных затрат на производство, хранение, уничтожение ключевых материалов. Тем не менее, совершенно стойкие шифры типа Вернама всё же нашли практическое применение для защиты особо важных линий связи с относительно небольшим объёмом информации. Так, например, англичане и американцы использовали шифры типа Вернама во время Второй мировой войны. Шифр Вернама по модулю 2 использовался на правительственной «горячей линии» между Вашингтоном и Москвой, где ключевые материалы представляли собой бумажные ленты, на которые знаки ключевой последовательности наносились с помощью перфорации[2].

На практике можно один раз физически передать носитель информации с длинным истинно случайным ключом, а потом по мере необходимости пересылать сообщения. На этом основана идея шифроблокнотов: шифровальщик по дипломатической почте или при личной встрече снабжается блокнотом, каждая страница которого содержит ключи. Такой же блокнот есть и у принимающей стороны. Использованные страницы уничтожаются[8].

Недостатки
Для работы шифра Вернама необходима истинно случайная последовательность (ключ). По определению, последовательность, полученная с использованием любого алгоритма, является не истинно случайной, а псевдослучайной. То есть, нужно получить случайную последовательность не алгоритмически (а, например, используя радиоактивный распад, создаваемый электронным генератором белого шума, или другие достаточно случайные события). Чтобы сделать распределение предельно близким к равномерному, случайная последовательность обычно пропускается через хэш-функцию наподобие MD5[9].
Недостатком использования шифра Вернама является отсутствие подтверждения подлинности и целостности сообщения. Получатель не может удостовериться в отсутствии повреждений или в подлинности отправителя. Если третья сторона каким-нибудь образом узнает сообщение, она легко восстановит ключ и сможет подменить послание на другое такой же длины. Решением проблемы является применение хэш-функции. От открытого текста вычисляется хэш-функция, и её значение шифруется вместе с сообщением. При каком-либо изменении сообщения значение хэш-функции изменится. Таким образом, даже если злоумышленник заполучил шифроблокнот, не зная алгоритм вычисления хэш-функции, он не сможет использовать его для передачи информации[8].
Под рукой всегда необходимо иметь достаточное количество ключей, которые могут понадобиться в дальнейшем для шифрования больших объёмов открытого текста. Реальный же объём текста зачастую трудно оценить заранее, в особенности это касается дипломатической и военной сферы, где ситуация способна меняться быстро и непредсказуемо. Это может приводить к нехватке ключей, что может заставить шифровальщика либо использовать ключ(и) повторно, либо полностью прервать шифрованную связь.
Проблемой является защищённая передача последовательности и сохранение её в тайне. Если существует надёжно защищённый от перехвата канал передачи сообщений, шифры вообще не нужны: секретные сообщения можно передавать по этому каналу. Если же передавать ключ системы Вернама с помощью другого шифра (например, DES), то полученный шифр окажется защищённым ровно настолько, насколько защищён DES. При этом, поскольку длина ключа та же, что и длина сообщения, передать его не проще, чем сообщение. Шифроблокнот на физическом носителе можно украсть или скопировать[8].
Шифр Вернама чувствителен к любому нарушению процедуры шифрования. Бывали случаи, когда одна и та же страница блокнота по различным причинам применялась дважды. Например, среди всего объёма советской шифрованной переписки, перехваченной разведкой США в 40-х годах прошлого века, были обнаружены сообщения, закрытые дважды использованной гаммой. Период этот длился не очень долго, потому что уже после первых успехов американских криптоаналитиков в конце 1940-х годов в спецслужбах СССР узнали о серьёзных проблемах с надёжностью своей шифропереписки. Такие сообщения были расшифрованы в течение 40 последующих лет в рамках секретного проекта «Venona», документы которого были не так давно рассекречены и выложены на сайте АНБ[10].

FOPEN(3)                  Linux Programmer's Manual                 FOPEN(3)
NAME         top
       fopen, fdopen, freopen - stream open functions
SYNOPSIS         top
       #include <stdio.h>

       FILE *fopen(const char *pathname, const char *mode);

       FILE *fdopen(int fd, const char *mode);

       FILE *freopen(const char *pathname, const char *mode, FILE *stream);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fdopen(): _POSIX_C_SOURCE
DESCRIPTION         top
       The fopen() function opens the file whose name is the string pointed
       to by pathname and associates a stream with it.

       The argument mode points to a string beginning with one of the
       following sequences (possibly followed by additional characters, as
       described below):

       r      Open text file for reading.  The stream is positioned at the
              beginning of the file.

       r+     Open for reading and writing.  The stream is positioned at the
              beginning of the file.

       w      Truncate file to zero length or create text file for writing.
              The stream is positioned at the beginning of the file.

       w+     Open for reading and writing.  The file is created if it does
              not exist, otherwise it is truncated.  The stream is
              positioned at the beginning of the file.

       a      Open for appending (writing at end of file).  The file is
              created if it does not exist.  The stream is positioned at the
              end of the file.

       a+     Open for reading and appending (writing at end of file).  The
              file is created if it does not exist.  The initial file
              position for reading is at the beginning of the file, but
              output is always appended to the end of the file.

       The mode string can also include the letter 'b' either as a last
       character or as a character between the characters in any of the two-
       character strings described above.  This is strictly for
       compatibility with C89 and has no effect; the 'b' is ignored on all
       POSIX conforming systems, including Linux.  (Other systems may treat
       text files and binary files differently, and adding the 'b' may be a
       good idea if you do I/O to a binary file and expect that your program
       may be ported to non-UNIX environments.)

       See NOTES below for details of glibc extensions for mode.

       Any created file will have the mode S_IRUSR | S_IWUSR | S_IRGRP |
       S_IWGRP | S_IROTH | S_IWOTH (0666), as modified by the process's
       umask value (see umask(2)).

       Reads and writes may be intermixed on read/write streams in any
       order.  Note that ANSI C requires that a file positioning function
       intervene between output and input, unless an input operation
       encounters end-of-file.  (If this condition is not met, then a read
       is allowed to return the result of writes other than the most
       recent.)  Therefore it is good practice (and indeed sometimes
       necessary under Linux) to put an fseek(3) or fgetpos(3) operation
       between write and read operations on such a stream.  This operation
       may be an apparent no-op (as in fseek(..., 0L, SEEK_CUR) called for
       its synchronizing side effect).

       Opening a file in append mode (a as the first character of mode)
       causes all subsequent write operations to this stream to occur at
       end-of-file, as if preceded the call:

           fseek(stream, 0, SEEK_END);

       The file descriptor associated with the stream is opened as if by a
       call to open(2) with the following flags:

              ┌─────────────┬───────────────────────────────┐
              │fopen() mode │ open() flags                  │
              ├─────────────┼───────────────────────────────┤
              │     r       │ O_RDONLY                      │
              ├─────────────┼───────────────────────────────┤
              │     w       │ O_WRONLY | O_CREAT | O_TRUNC  │
              ├─────────────┼───────────────────────────────┤
              │     a       │ O_WRONLY | O_CREAT | O_APPEND │
              ├─────────────┼───────────────────────────────┤
              │     r+      │ O_RDWR                        │
              ├─────────────┼───────────────────────────────┤
              │     w+      │ O_RDWR | O_CREAT | O_TRUNC    │
              ├─────────────┼───────────────────────────────┤
              │     a+      │ O_RDWR | O_CREAT | O_APPEND   │
              └─────────────┴───────────────────────────────┘
   fdopen()
       The fdopen() function associates a stream with the existing file
       descriptor, fd.  The mode of the stream (one of the values "r", "r+",
       "w", "w+", "a", "a+") must be compatible with the mode of the file
       descriptor.  The file position indicator of the new stream is set to
       that belonging to fd, and the error and end-of-file indicators are
       cleared.  Modes "w" or "w+" do not cause truncation of the file.  The
       file descriptor is not dup'ed, and will be closed when the stream
       created by fdopen() is closed.  The result of applying fdopen() to a
       shared memory object is undefined.

   freopen()
       The freopen() function opens the file whose name is the string
       pointed to by pathname and associates the stream pointed to by stream
       with it.  The original stream (if it exists) is closed.  The mode
       argument is used just as in the fopen() function.

       If the pathname argument is a null pointer, freopen() changes the
       mode of the stream to that specified in mode; that is, freopen()
       reopens the pathname that is associated with the stream.  The speci‐
       fication for this behavior was added in the C99 standard, which says:

              In this case, the file descriptor associated with the stream
              need not be closed if the call to freopen() succeeds.  It is
              implementation-defined which changes of mode are permitted (if
              any), and under what circumstances.

       The primary use of the freopen() function is to change the file asso‐
       ciated with a standard text stream (stderr, stdin, or stdout).
RETURN VALUE         top
       Upon successful completion fopen(), fdopen() and freopen() return a
       FILE pointer.  Otherwise, NULL is returned and errno is set to
       indicate the error.
ERRORS         top
       EINVAL The mode provided to fopen(), fdopen(), or freopen() was
              invalid.

       The fopen(), fdopen() and freopen() functions may also fail and set
       errno for any of the errors specified for the routine malloc(3).

       The fopen() function may also fail and set errno for any of the
       errors specified for the routine open(2).

       The fdopen() function may also fail and set errno for any of the
       errors specified for the routine fcntl(2).

       The freopen() function may also fail and set errno for any of the
       errors specified for the routines open(2), fclose(3), and fflush(3).
ATTRIBUTES         top
       For an explanation of the terms used in this section, see
       attributes(7).

       ┌─────────────────────────────┬───────────────┬─────────┐
       │Interface                    │ Attribute     │ Value   │
       ├─────────────────────────────┼───────────────┼─────────┤
       │fopen(), fdopen(), freopen() │ Thread safety │ MT-Safe │
       └─────────────────────────────┴───────────────┴─────────┘
CONFORMING TO         top
       fopen(), freopen(): POSIX.1-2001, POSIX.1-2008, C89, C99.

       fdopen(): POSIX.1-2001, POSIX.1-2008.
NOTES         top
   Glibc notes
       The GNU C library allows the following extensions for the string
       specified in mode:

       c (since glibc 2.3.3)
              Do not make the open operation, or subsequent read and write
              operations, thread cancellation points.  This flag is ignored
              for fdopen().

       e (since glibc 2.7)
              Open the file with the O_CLOEXEC flag.  See open(2) for more
              information.  This flag is ignored for fdopen().

       m (since glibc 2.3)
              Attempt to access the file using mmap(2), rather than I/O
              system calls (read(2), write(2)).  Currently, use of mmap(2)
              is attempted only for a file opened for reading.

       x      Open the file exclusively (like the O_EXCL flag of open(2)).
              If the file already exists, fopen() fails, and sets errno to
              EEXIST.  This flag is ignored for fdopen().

       In addition to the above characters, fopen() and freopen() support
       the following syntax in mode:

           ,ccs=string

       The given string is taken as the name of a coded character set and
       the stream is marked as wide-oriented.  Thereafter, internal
       conversion functions convert I/O to and from the character set
       string.  If the ,ccs=string syntax is not specified, then the wide-
       orientation of the stream is determined by the first file operation.
       If that operation is a wide-character operation, the stream is marked
       wide-oriented, and functions to convert to the coded character set
       are loaded.
BUGS         top
       When parsing for individual flag characters in mode (i.e., the
       characters preceding the "ccs" specification), the glibc
       implementation of fopen() and freopen() limits the number of
       characters examined in mode to 7 (or, in glibc versions before 2.14,
       to 6, which was not enough to include possible specifications such as
       "rb+cmxe").  The current implementation of fdopen() parses at most 5
       characters in mode.

READ(2)                   Linux Programmer's Manual                  READ(2)
NAME         top
       read - read from a file descriptor
SYNOPSIS         top
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);
DESCRIPTION         top
       read() attempts to read up to count bytes from file descriptor fd
       into the buffer starting at buf.

       On files that support seeking, the read operation commences at the
       file offset, and the file offset is incremented by the number of
       bytes read.  If the file offset is at or past the end of file, no
       bytes are read, and read() returns zero.

       If count is zero, read() may detect the errors described below.  In
       the absence of any errors, or if read() does not check for errors, a
       read() with a count of 0 returns zero and has no other effects.

       According to POSIX.1, if count is greater than SSIZE_MAX, the result
       is implementation-defined; see NOTES for the upper limit on Linux.
RETURN VALUE         top
       On success, the number of bytes read is returned (zero indicates end
       of file), and the file position is advanced by this number.  It is
       not an error if this number is smaller than the number of bytes
       requested; this may happen for example because fewer bytes are
       actually available right now (maybe because we were close to end-of-
       file, or because we are reading from a pipe, or from a terminal), or
       because read() was interrupted by a signal.  See also NOTES.

       On error, -1 is returned, and errno is set appropriately.  In this
       case, it is left unspecified whether the file position (if any)
       changes.
ERRORS         top
       EAGAIN The file descriptor fd refers to a file other than a socket
              and has been marked nonblocking (O_NONBLOCK), and the read
              would block.  See open(2) for further details on the
              O_NONBLOCK flag.

       EAGAIN or EWOULDBLOCK
              The file descriptor fd refers to a socket and has been marked
              nonblocking (O_NONBLOCK), and the read would block.
              POSIX.1-2001 allows either error to be returned for this case,
              and does not require these constants to have the same value,
              so a portable application should check for both possibilities.

       EBADF  fd is not a valid file descriptor or is not open for reading.

       EFAULT buf is outside your accessible address space.

       EINTR  The call was interrupted by a signal before any data was read;
              see signal(7).

       EINVAL fd is attached to an object which is unsuitable for reading;
              or the file was opened with the O_DIRECT flag, and either the
              address specified in buf, the value specified in count, or the
              file offset is not suitably aligned.

       EINVAL fd was created via a call to timerfd_create(2) and the wrong
              size buffer was given to read(); see timerfd_create(2) for
              further information.

       EIO    I/O error.  This will happen for example when the process is
              in a background process group, tries to read from its
              controlling terminal, and either it is ignoring or blocking
              SIGTTIN or its process group is orphaned.  It may also occur
              when there is a low-level I/O error while reading from a disk
              or tape.  A further possible cause of EIO on networked
              filesystems is when an advisory lock had been taken out on the
              file descriptor and this lock has been lost.  See the Lost
              locks section of fcntl(2) for further details.

       EISDIR fd refers to a directory.

       Other errors may occur, depending on the object connected to fd.
       CONFORMING TO         top
       SVr4, 4.3BSD, POSIX.1-2001.
NOTES         top
       The types size_t and ssize_t are, respectively, unsigned and signed
       integer data types specified by POSIX.1.

       On Linux, read() (and similar system calls) will transfer at most
       0x7ffff000 (2,147,479,552) bytes, returning the number of bytes
       actually transferred.  (This is true on both 32-bit and 64-bit
       systems.)

       On NFS filesystems, reading small amounts of data will update the
       timestamp only the first time, subsequent calls may not do so.  This
       is caused by client side attribute caching, because most if not all
       NFS clients leave st_atime (last file access time) updates to the
       server, and client side reads satisfied from the client's cache will
       not cause st_atime updates on the server as there are no server-side
       reads.  UNIX semantics can be obtained by disabling client-side
       attribute caching, but in most situations this will substantially
       increase server load and decrease performance.
BUGS         top
       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 ("Thread
       Interactions with Regular File Operations"):

           All of the following functions shall be atomic with respect to
           each other in the effects specified in POSIX.1-2008 when they
           operate on regular files or symbolic links: ...

       Among the APIs subsequently listed are read() and readv(2).  And
       among the effects that should be atomic across threads (and
       processes) are updates of the file offset.  However, on Linux before
       version 3.14, this was not the case: if two processes that share an
       open file description (see open(2)) perform a read() (or readv(2)) at
       the same time, then the I/O operations were not atomic with respect
       updating the file offset, with the result that the reads in the two
       processes might (incorrectly) overlap in the blocks of data that they
       obtained.  This problem was fixed in Linux 3.14.

       WRITE(2)                  Linux Programmer's Manual                 WRITE(2)
NAME         top
       write - write to a file descriptor
SYNOPSIS         top
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count);
DESCRIPTION         top
       write() writes up to count bytes from the buffer starting at buf to
       the file referred to by the file descriptor fd.

       The number of bytes written may be less than count if, for example,
       there is insufficient space on the underlying physical medium, or the
       RLIMIT_FSIZE resource limit is encountered (see setrlimit(2)), or the
       call was interrupted by a signal handler after having written less
       than count bytes.  (See also pipe(7).)

       For a seekable file (i.e., one to which lseek(2) may be applied, for
       example, a regular file) writing takes place at the file offset, and
       the file offset is incremented by the number of bytes actually
       written.  If the file was open(2)ed with O_APPEND, the file offset is
       first set to the end of the file before writing.  The adjustment of
       the file offset and the write operation are performed as an atomic
       step.

       POSIX requires that a read(2) that can be proved to occur after a
       write() has returned will return the new data.  Note that not all
       filesystems are POSIX conforming.

       According to POSIX.1, if count is greater than SSIZE_MAX, the result
       is implementation-defined; see NOTES for the upper limit on Linux.
RETURN VALUE         top
       On success, the number of bytes written is returned (zero indicates
       nothing was written).  It is not an error if this number is smaller
       than the number of bytes requested; this may happen for example
       because the disk device was filled.  See also NOTES.

       On error, -1 is returned, and errno is set appropriately.

       If count is zero and fd refers to a regular file, then write() may
       return a failure status if one of the errors below is detected.  If
       no errors are detected, or error detection is not performed, 0 will
       be returned without causing any other effect.  If count is zero and
       fd refers to a file other than a regular file, the results are not
       specified.
ERRORS         top
       EAGAIN The file descriptor fd refers to a file other than a socket
              and has been marked nonblocking (O_NONBLOCK), and the write
              would block.  See open(2) for further details on the
              O_NONBLOCK flag.

       EAGAIN or EWOULDBLOCK
              The file descriptor fd refers to a socket and has been marked
              nonblocking (O_NONBLOCK), and the write would block.
              POSIX.1-2001 allows either error to be returned for this case,
              and does not require these constants to have the same value,
              so a portable application should check for both possibilities.

       EBADF  fd is not a valid file descriptor or is not open for writing.

       EDESTADDRREQ
              fd refers to a datagram socket for which a peer address has
              not been set using connect(2).

       EDQUOT The user's quota of disk blocks on the filesystem containing
              the file referred to by fd has been exhausted.

       EFAULT buf is outside your accessible address space.

       EFBIG  An attempt was made to write a file that exceeds the
              implementation-defined maximum file size or the process's file
              size limit, or to write at a position past the maximum allowed
              offset.

       EINTR  The call was interrupted by a signal before any data was
              written; see signal(7).

       EINVAL fd is attached to an object which is unsuitable for writing;
              or the file was opened with the O_DIRECT flag, and either the
              address specified in buf, the value specified in count, or the
              file offset is not suitably aligned.

       EIO    A low-level I/O error occurred while modifying the inode.
              This error may relate to the write-back of data written by an
              earlier write(2), which may have been issued to a different
              file descriptor on the same file.  Since Linux 4.13, errors
              from write-back come with a promise that they may be reported
              by subsequent.  write(2) requests, and will be reported by a
              subsequent fsync(2) (whether or not they were also reported by
              write(2)).  An alternate cause of EIO on networked filesystems
              is when an advisory lock had been taken out on the file
              descriptor and this lock has been lost.  See the Lost locks
              section of fcntl(2) for further details.

       ENOSPC The device containing the file referred to by fd has no room
              for the data.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EPIPE  fd is connected to a pipe or socket whose reading end is
              closed.  When this happens the writing process will also
              receive a SIGPIPE signal.  (Thus, the write return value is
              seen only if the program catches, blocks or ignores this
              signal.)

       Other errors may occur, depending on the object connected to fd.
CONFORMING TO         top
       SVr4, 4.3BSD, POSIX.1-2001.

       Under SVr4 a write may be interrupted and return EINTR at any point,
       not just before any data is written.
NOTES         top
       The types size_t and ssize_t are, respectively, unsigned and signed
       integer data types specified by POSIX.1.

       A successful return from write() does not make any guarantee that
       data has been committed to disk.  On some filesystems, including NFS,
       it does not even guarantee that space has successfully been reserved
       for the data.  In this case, some errors might be delayed until a
       future write(2), fsync(2), or even close(2).  The only way to be sure
       is to call fsync(2) after you are done writing all your data.

       If a write() is interrupted by a signal handler before any bytes are
       written, then the call fails with the error EINTR; if it is
       interrupted after at least one byte has been written, the call
       succeeds, and returns the number of bytes written.

       On Linux, write() (and similar system calls) will transfer at most
       0x7ffff000 (2,147,479,552) bytes, returning the number of bytes
       actually transferred.  (This is true on both 32-bit and 64-bit
       systems.)
BUGS         top
       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 ("Thread
       Interactions with Regular File Operations"):

           All of the following functions shall be atomic with respect to
           each other in the effects specified in POSIX.1-2008 when they
           operate on regular files or symbolic links: ...

       Among the APIs subsequently listed are write() and writev(2).  And
       among the effects that should be atomic across threads (and
       processes) are updates of the file offset.  However, on Linux before
       version 3.14, this was not the case: if two processes that share an
       open file description (see open(2)) perform a write() (or writev(2))
       at the same time, then the I/O operations were not atomic with
       respect updating the file offset, with the result that the blocks of
       data output by the two processes might (incorrectly) overlap.  This
       problem was fixed in Linux 3.14.

       CLOSE(2)                  Linux Programmer's Manual                 CLOSE(2)
NAME         top
       close - close a file descriptor
SYNOPSIS         top
       #include <unistd.h>

       int close(int fd);
DESCRIPTION         top
       close() closes a file descriptor, so that it no longer refers to any
       file and may be reused.  Any record locks (see fcntl(2)) held on the
       file it was associated with, and owned by the process, are removed
       (regardless of the file descriptor that was used to obtain the lock).

       If fd is the last file descriptor referring to the underlying open
       file description (see open(2)), the resources associated with the
       open file description are freed; if the file descriptor was the last
       reference to a file which has been removed using unlink(2), the file
       is deleted.
RETURN VALUE         top
       close() returns zero on success.  On error, -1 is returned, and errno
       is set appropriately.
ERRORS         top
       EBADF  fd isn't a valid open file descriptor.

       EINTR  The close() call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred.

       ENOSPC, EDQUOT
              On NFS, these errors are not normally reported against the
              first write which exceeds the available storage space, but
              instead against a subsequent write(2), fsync(2), or close(2).

       See NOTES for a discussion of why close() should not be retried after
       an error.
CONFORMING TO         top
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.
NOTES         top
       A successful close does not guarantee that the data has been
       successfully saved to disk, as the kernel uses the buffer cache to
       defer writes.  Typically, filesystems do not flush buffers when a
       file is closed.  If you need to be sure that the data is physically
       stored on the underlying disk, use fsync(2).  (It will depend on the
       disk hardware at this point.)

       The close-on-exec file descriptor flag can be used to ensure that a
       file descriptor is automatically closed upon a successful execve(2);
       see fcntl(2) for details.

       It is probably unwise to close file descriptors while they may be in
       use by system calls in other threads in the same process.  Since a
       file descriptor may be reused, there are some obscure race conditions
       that may cause unintended side effects.

   Dealing with error returns from close()
       A careful programmer will check the return value of close(), since it
       is quite possible that errors on a previous write(2) operation are
       reported only on the final close() that releases the open file
       description.  Failing to check the return value when closing a file
       may lead to silent loss of data.  This can especially be observed
       with NFS and with disk quota.

       Note, however, that a failure return should be used only for
       diagnostic purposes (i.e., a warning to the application that there
       may still be I/O pending or there may have been failed I/O) or
       remedial purposes (e.g., writing the file once more or creating a
       backup).

       Retrying the close() after a failure return is the wrong thing to do,
       since this may cause a reused file descriptor from another thread to
       be closed.  This can occur because the Linux kernel always releases
       the file descriptor early in the close operation, freeing it for
       reuse; the steps that may return an error, such as flushing data to
       the filesystem or device, occur only later in the close operation.

       Many other implementations similarly always close the file descriptor
       (except in the case of EBADF, meaning that the file descriptor was
       invalid) even if they subsequently report an error on return from
       close().  POSIX.1 is currently silent on this point, but there are
       plans to mandate this behavior in the next major release of the
       standard

       A careful programmer who wants to know about I/O errors may precede
       close() with a call to fsync(2).

       The EINTR error is a somewhat special case.  Regarding the EINTR
       error, POSIX.1-2013 says:

              If close() is interrupted by a signal that is to be caught, it
              shall return -1 with errno set to EINTR and the state of
              fildes is unspecified.

       This permits the behavior that occurs on Linux and many other
       implementations, where, as with other errors that may be reported by
       close(), the file descriptor is guaranteed to be closed.  However, it
       also permits another possibility: that the implementation returns an
       EINTR error and keeps the file descriptor open.  (According to its
       documentation, HP-UX's close() does this.)  The caller must then once
       more use close() to close the file descriptor, to avoid file
       descriptor leaks.  This divergence in implementation behaviors
       provides a difficult hurdle for portable applications, since on many
       implementations, close() must not be called again after an EINTR
       error, and on at least one, close() must be called again.  There are
       plans to address this conundrum for the next major release of the
       POSIX.1 standard.

       PTHREAD_CREATE(3)         Linux Programmer's Manual        PTHREAD_CREATE(3)
NAME         top
       pthread_create - create a new thread
SYNOPSIS         top
       #include <pthread.h>

       int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);

       Compile and link with -pthread.
DESCRIPTION         top
       The pthread_create() function starts a new thread in the calling
       process.  The new thread starts execution by invoking
       start_routine(); arg is passed as the sole argument of
       start_routine().

       The new thread terminates in one of the following ways:

       * It calls pthread_exit(3), specifying an exit status value that is
         available to another thread in the same process that calls
         pthread_join(3).

       * It returns from start_routine().  This is equivalent to calling
         pthread_exit(3) with the value supplied in the return statement.

       * It is canceled (see pthread_cancel(3)).

       * Any of the threads in the process calls exit(3), or the main thread
         performs a return from main().  This causes the termination of all
         threads in the process.

       The attr argument points to a pthread_attr_t structure whose contents
       are used at thread creation time to determine attributes for the new
       thread; this structure is initialized using pthread_attr_init(3) and
       related functions.  If attr is NULL, then the thread is created with
       default attributes.

       Before returning, a successful call to pthread_create() stores the ID
       of the new thread in the buffer pointed to by thread; this identifier
       is used to refer to the thread in subsequent calls to other pthreads
       functions.

       The new thread inherits a copy of the creating thread's signal mask
       (pthread_sigmask(3)).  The set of pending signals for the new thread
       is empty (sigpending(2)).  The new thread does not inherit the
       creating thread's alternate signal stack (sigaltstack(2)).

       The new thread inherits the calling thread's floating-point
       environment (fenv(3)).

       The initial value of the new thread's CPU-time clock is 0 (see
       pthread_getcpuclockid(3)).

   Linux-specific details
       The new thread inherits copies of the calling thread's capability
       sets (see capabilities(7)) and CPU affinity mask (see
       sched_setaffinity(2)).
RETURN VALUE         top
       On success, pthread_create() returns 0; on error, it returns an error
       number, and the contents of *thread are undefined.
ERRORS         top
       EAGAIN Insufficient resources to create another thread.

       EAGAIN A system-imposed limit on the number of threads was
              encountered.  There are a number of limits that may trigger
              this error: the RLIMIT_NPROC soft resource limit (set via
              setrlimit(2)), which limits the number of processes and
              threads for a real user ID, was reached; the kernel's system-
              wide limit on the number of processes and threads,
              /proc/sys/kernel/threads-max, was reached (see proc(5)); or
              the maximum number of PIDs, /proc/sys/kernel/pid_max, was
              reached (see proc(5)).

       EINVAL Invalid settings in attr.

       EPERM  No permission to set the scheduling policy and parameters
              specified in attr.
ATTRIBUTES         top
       For an explanation of the terms used in this section, see
       attributes(7).

       ┌─────────────────┬───────────────┬─────────┐
       │Interface        │ Attribute     │ Value   │
       ├─────────────────┼───────────────┼─────────┤
       │pthread_create() │ Thread safety │ MT-Safe │
       └─────────────────┴───────────────┴─────────┘
CONFORMING TO         top
       POSIX.1-2001, POSIX.1-2008.
NOTES         top
       See pthread_self(3) for further information on the thread ID returned
       in *thread by pthread_create().  Unless real-time scheduling policies
       are being employed, after a call to pthread_create(), it is
       indeterminate which thread—the caller or the new thread—will next
       execute.

       A thread may either be joinable or detached.  If a thread is
       joinable, then another thread can call pthread_join(3) to wait for
       the thread to terminate and fetch its exit status.  Only when a
       terminated joinable thread has been joined are the last of its
       resources released back to the system.  When a detached thread
       terminates, its resources are automatically released back to the
       system: it is not possible to join with the thread in order to obtain
       its exit status.  Making a thread detached is useful for some types
       of daemon threads whose exit status the application does not need to
       care about.  By default, a new thread is created in a joinable state,
       unless attr was set to create the thread in a detached state (using
       pthread_attr_setdetachstate(3)).

       On Linux/x86-32, the default stack size for a new thread is 2
       megabytes.  Under the NPTL threading implementation, if the
       RLIMIT_STACK soft resource limit at the time the program started has
       any value other than "unlimited", then it determines the default
       stack size of new threads.  Using pthread_attr_setstacksize(3), the
       stack size attribute can be explicitly set in the attr argument used
       to create a thread, in order to obtain a stack size other than the
       default.
BUGS         top
       In the obsolete LinuxThreads implementation, each of the threads in a
       process has a different process ID.  This is in violation of the
       POSIX threads specification, and is the source of many other
       nonconformances to the standard; see pthreads(7).
